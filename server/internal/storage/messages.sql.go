// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: messages.sql

package storage

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const enqueueMessage = `-- name: EnqueueMessage :one
INSERT INTO messages (user_id, group_id, sender, recipients, subject, headers, body, status)
VALUES ($1, $2, $3, $4, $5, $6, $7, 'queued')
RETURNING id, sender, recipients, subject, headers, body, status, provider_id, enqueued_at, processed_at, storage_ref, group_id, user_id
`

type EnqueueMessageParams struct {
	UserID     pgtype.UUID    `json:"user_id"`
	GroupID    pgtype.UUID    `json:"group_id"`
	Sender     string         `json:"sender"`
	Recipients []byte         `json:"recipients"`
	Subject    sql.NullString `json:"subject"`
	Headers    []byte         `json:"headers"`
	Body       pgtype.Text    `json:"body"`
}

func (q *Queries) EnqueueMessage(ctx context.Context, arg EnqueueMessageParams) (Message, error) {
	row := q.db.QueryRow(ctx, enqueueMessage,
		arg.UserID,
		arg.GroupID,
		arg.Sender,
		arg.Recipients,
		arg.Subject,
		arg.Headers,
		arg.Body,
	)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.Sender,
		&i.Recipients,
		&i.Subject,
		&i.Headers,
		&i.Body,
		&i.Status,
		&i.ProviderID,
		&i.EnqueuedAt,
		&i.ProcessedAt,
		&i.StorageRef,
		&i.GroupID,
		&i.UserID,
	)
	return i, err
}

const enqueueMessageMetadata = `-- name: EnqueueMessageMetadata :one
INSERT INTO messages (user_id, group_id, sender, recipients, subject, headers, storage_ref, status)
VALUES ($1, $2, $3, $4, $5, $6, $7, 'queued')
RETURNING id, sender, recipients, subject, headers, body, status, provider_id, enqueued_at, processed_at, storage_ref, group_id, user_id
`

type EnqueueMessageMetadataParams struct {
	UserID     pgtype.UUID    `json:"user_id"`
	GroupID    pgtype.UUID    `json:"group_id"`
	Sender     string         `json:"sender"`
	Recipients []byte         `json:"recipients"`
	Subject    sql.NullString `json:"subject"`
	Headers    []byte         `json:"headers"`
	StorageRef pgtype.Text    `json:"storage_ref"`
}

func (q *Queries) EnqueueMessageMetadata(ctx context.Context, arg EnqueueMessageMetadataParams) (Message, error) {
	row := q.db.QueryRow(ctx, enqueueMessageMetadata,
		arg.UserID,
		arg.GroupID,
		arg.Sender,
		arg.Recipients,
		arg.Subject,
		arg.Headers,
		arg.StorageRef,
	)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.Sender,
		&i.Recipients,
		&i.Subject,
		&i.Headers,
		&i.Body,
		&i.Status,
		&i.ProviderID,
		&i.EnqueuedAt,
		&i.ProcessedAt,
		&i.StorageRef,
		&i.GroupID,
		&i.UserID,
	)
	return i, err
}

const getMessageByID = `-- name: GetMessageByID :one
SELECT id, sender, recipients, subject, headers, body, status, provider_id, enqueued_at, processed_at, storage_ref, group_id, user_id FROM messages WHERE id = $1
`

func (q *Queries) GetMessageByID(ctx context.Context, id uuid.UUID) (Message, error) {
	row := q.db.QueryRow(ctx, getMessageByID, id)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.Sender,
		&i.Recipients,
		&i.Subject,
		&i.Headers,
		&i.Body,
		&i.Status,
		&i.ProviderID,
		&i.EnqueuedAt,
		&i.ProcessedAt,
		&i.StorageRef,
		&i.GroupID,
		&i.UserID,
	)
	return i, err
}

const getQueuedMessages = `-- name: GetQueuedMessages :many
SELECT id, sender, recipients, subject, headers, body, status, provider_id, enqueued_at, processed_at, storage_ref, group_id, user_id FROM messages WHERE status = 'queued' ORDER BY enqueued_at ASC LIMIT $1
`

func (q *Queries) GetQueuedMessages(ctx context.Context, limit int32) ([]Message, error) {
	rows, err := q.db.Query(ctx, getQueuedMessages, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Message
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.Sender,
			&i.Recipients,
			&i.Subject,
			&i.Headers,
			&i.Body,
			&i.Status,
			&i.ProviderID,
			&i.EnqueuedAt,
			&i.ProcessedAt,
			&i.StorageRef,
			&i.GroupID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMessagesByGroupID = `-- name: ListMessagesByGroupID :many
SELECT id, sender, recipients, subject, headers, body, status, provider_id, enqueued_at, processed_at, storage_ref, group_id, user_id FROM messages WHERE group_id = $1 ORDER BY enqueued_at DESC LIMIT $2
`

type ListMessagesByGroupIDParams struct {
	GroupID pgtype.UUID `json:"group_id"`
	Limit   int32       `json:"limit"`
}

func (q *Queries) ListMessagesByGroupID(ctx context.Context, arg ListMessagesByGroupIDParams) ([]Message, error) {
	rows, err := q.db.Query(ctx, listMessagesByGroupID, arg.GroupID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Message
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.Sender,
			&i.Recipients,
			&i.Subject,
			&i.Headers,
			&i.Body,
			&i.Status,
			&i.ProviderID,
			&i.EnqueuedAt,
			&i.ProcessedAt,
			&i.StorageRef,
			&i.GroupID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMessageStatus = `-- name: UpdateMessageStatus :exec
UPDATE messages SET status = $2, processed_at = NOW() WHERE id = $1
`

type UpdateMessageStatusParams struct {
	ID     uuid.UUID     `json:"id"`
	Status MessageStatus `json:"status"`
}

func (q *Queries) UpdateMessageStatus(ctx context.Context, arg UpdateMessageStatusParams) error {
	_, err := q.db.Exec(ctx, updateMessageStatus, arg.ID, arg.Status)
	return err
}
