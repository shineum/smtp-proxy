// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: delivery_logs.sql

package storage

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const averageDeliveryDuration = `-- name: AverageDeliveryDuration :many
SELECT provider, AVG(duration_ms)::integer as avg_duration_ms, COUNT(*) as count
FROM delivery_logs
WHERE duration_ms IS NOT NULL AND created_at >= $1 AND created_at <= $2
GROUP BY provider
`

type AverageDeliveryDurationParams struct {
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
}

type AverageDeliveryDurationRow struct {
	Provider      sql.NullString `json:"provider"`
	AvgDurationMs int32          `json:"avg_duration_ms"`
	Count         int64          `json:"count"`
}

func (q *Queries) AverageDeliveryDuration(ctx context.Context, arg AverageDeliveryDurationParams) ([]AverageDeliveryDurationRow, error) {
	rows, err := q.db.Query(ctx, averageDeliveryDuration, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AverageDeliveryDurationRow
	for rows.Next() {
		var i AverageDeliveryDurationRow
		if err := rows.Scan(&i.Provider, &i.AvgDurationMs, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countDeliveryLogsByGroup = `-- name: CountDeliveryLogsByGroup :many
SELECT group_id, status, COUNT(*) as count FROM delivery_logs
WHERE group_id IS NOT NULL AND created_at >= $1 AND created_at <= $2
GROUP BY group_id, status
`

type CountDeliveryLogsByGroupParams struct {
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
}

type CountDeliveryLogsByGroupRow struct {
	GroupID pgtype.UUID `json:"group_id"`
	Status  string      `json:"status"`
	Count   int64       `json:"count"`
}

func (q *Queries) CountDeliveryLogsByGroup(ctx context.Context, arg CountDeliveryLogsByGroupParams) ([]CountDeliveryLogsByGroupRow, error) {
	rows, err := q.db.Query(ctx, countDeliveryLogsByGroup, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CountDeliveryLogsByGroupRow
	for rows.Next() {
		var i CountDeliveryLogsByGroupRow
		if err := rows.Scan(&i.GroupID, &i.Status, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countDeliveryLogsByProvider = `-- name: CountDeliveryLogsByProvider :many
SELECT provider, status, COUNT(*) as count FROM delivery_logs
WHERE created_at >= $1 AND created_at <= $2
GROUP BY provider, status
`

type CountDeliveryLogsByProviderParams struct {
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
}

type CountDeliveryLogsByProviderRow struct {
	Provider sql.NullString `json:"provider"`
	Status   string         `json:"status"`
	Count    int64          `json:"count"`
}

func (q *Queries) CountDeliveryLogsByProvider(ctx context.Context, arg CountDeliveryLogsByProviderParams) ([]CountDeliveryLogsByProviderRow, error) {
	rows, err := q.db.Query(ctx, countDeliveryLogsByProvider, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CountDeliveryLogsByProviderRow
	for rows.Next() {
		var i CountDeliveryLogsByProviderRow
		if err := rows.Scan(&i.Provider, &i.Status, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countDeliveryLogsByStatus = `-- name: CountDeliveryLogsByStatus :many
SELECT status, COUNT(*) as count FROM delivery_logs
WHERE created_at >= $1 AND created_at <= $2
GROUP BY status
`

type CountDeliveryLogsByStatusParams struct {
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
}

type CountDeliveryLogsByStatusRow struct {
	Status string `json:"status"`
	Count  int64  `json:"count"`
}

func (q *Queries) CountDeliveryLogsByStatus(ctx context.Context, arg CountDeliveryLogsByStatusParams) ([]CountDeliveryLogsByStatusRow, error) {
	rows, err := q.db.Query(ctx, countDeliveryLogsByStatus, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CountDeliveryLogsByStatusRow
	for rows.Next() {
		var i CountDeliveryLogsByStatusRow
		if err := rows.Scan(&i.Status, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createDeliveryLog = `-- name: CreateDeliveryLog :one
INSERT INTO delivery_logs (
    message_id, provider_id, group_id, user_id, status, provider,
    provider_message_id, response_code, response_body,
    retry_count, last_error, metadata,
    duration_ms, attempt_number
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
RETURNING id, message_id, provider_id, status, response_code, response_body, delivered_at, provider, provider_message_id, retry_count, last_error, metadata, created_at, updated_at, duration_ms, attempt_number, user_id, group_id
`

type CreateDeliveryLogParams struct {
	MessageID         uuid.UUID      `json:"message_id"`
	ProviderID        pgtype.UUID    `json:"provider_id"`
	GroupID           pgtype.UUID    `json:"group_id"`
	UserID            pgtype.UUID    `json:"user_id"`
	Status            string         `json:"status"`
	Provider          sql.NullString `json:"provider"`
	ProviderMessageID sql.NullString `json:"provider_message_id"`
	ResponseCode      pgtype.Int4    `json:"response_code"`
	ResponseBody      pgtype.Text    `json:"response_body"`
	RetryCount        int32          `json:"retry_count"`
	LastError         pgtype.Text    `json:"last_error"`
	Metadata          []byte         `json:"metadata"`
	DurationMs        pgtype.Int4    `json:"duration_ms"`
	AttemptNumber     int32          `json:"attempt_number"`
}

func (q *Queries) CreateDeliveryLog(ctx context.Context, arg CreateDeliveryLogParams) (DeliveryLog, error) {
	row := q.db.QueryRow(ctx, createDeliveryLog,
		arg.MessageID,
		arg.ProviderID,
		arg.GroupID,
		arg.UserID,
		arg.Status,
		arg.Provider,
		arg.ProviderMessageID,
		arg.ResponseCode,
		arg.ResponseBody,
		arg.RetryCount,
		arg.LastError,
		arg.Metadata,
		arg.DurationMs,
		arg.AttemptNumber,
	)
	var i DeliveryLog
	err := row.Scan(
		&i.ID,
		&i.MessageID,
		&i.ProviderID,
		&i.Status,
		&i.ResponseCode,
		&i.ResponseBody,
		&i.DeliveredAt,
		&i.Provider,
		&i.ProviderMessageID,
		&i.RetryCount,
		&i.LastError,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DurationMs,
		&i.AttemptNumber,
		&i.UserID,
		&i.GroupID,
	)
	return i, err
}

const getDeliveryLogByMessageID = `-- name: GetDeliveryLogByMessageID :one
SELECT id, message_id, provider_id, status, response_code, response_body, delivered_at, provider, provider_message_id, retry_count, last_error, metadata, created_at, updated_at, duration_ms, attempt_number, user_id, group_id FROM delivery_logs WHERE message_id = $1
`

func (q *Queries) GetDeliveryLogByMessageID(ctx context.Context, messageID uuid.UUID) (DeliveryLog, error) {
	row := q.db.QueryRow(ctx, getDeliveryLogByMessageID, messageID)
	var i DeliveryLog
	err := row.Scan(
		&i.ID,
		&i.MessageID,
		&i.ProviderID,
		&i.Status,
		&i.ResponseCode,
		&i.ResponseBody,
		&i.DeliveredAt,
		&i.Provider,
		&i.ProviderMessageID,
		&i.RetryCount,
		&i.LastError,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DurationMs,
		&i.AttemptNumber,
		&i.UserID,
		&i.GroupID,
	)
	return i, err
}

const getDeliveryLogByProviderMessageID = `-- name: GetDeliveryLogByProviderMessageID :one
SELECT id, message_id, provider_id, status, response_code, response_body, delivered_at, provider, provider_message_id, retry_count, last_error, metadata, created_at, updated_at, duration_ms, attempt_number, user_id, group_id FROM delivery_logs WHERE provider_message_id = $1
`

func (q *Queries) GetDeliveryLogByProviderMessageID(ctx context.Context, providerMessageID sql.NullString) (DeliveryLog, error) {
	row := q.db.QueryRow(ctx, getDeliveryLogByProviderMessageID, providerMessageID)
	var i DeliveryLog
	err := row.Scan(
		&i.ID,
		&i.MessageID,
		&i.ProviderID,
		&i.Status,
		&i.ResponseCode,
		&i.ResponseBody,
		&i.DeliveredAt,
		&i.Provider,
		&i.ProviderMessageID,
		&i.RetryCount,
		&i.LastError,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DurationMs,
		&i.AttemptNumber,
		&i.UserID,
		&i.GroupID,
	)
	return i, err
}

const incrementRetryCount = `-- name: IncrementRetryCount :exec
UPDATE delivery_logs
SET retry_count = retry_count + 1,
    last_error = $2,
    updated_at = NOW()
WHERE message_id = $1
`

type IncrementRetryCountParams struct {
	MessageID uuid.UUID   `json:"message_id"`
	LastError pgtype.Text `json:"last_error"`
}

func (q *Queries) IncrementRetryCount(ctx context.Context, arg IncrementRetryCountParams) error {
	_, err := q.db.Exec(ctx, incrementRetryCount, arg.MessageID, arg.LastError)
	return err
}

const listDeliveryLogsByGroupAndStatus = `-- name: ListDeliveryLogsByGroupAndStatus :many
SELECT id, message_id, provider_id, status, response_code, response_body, delivered_at, provider, provider_message_id, retry_count, last_error, metadata, created_at, updated_at, duration_ms, attempt_number, user_id, group_id FROM delivery_logs
WHERE group_id = $1 AND status = $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListDeliveryLogsByGroupAndStatusParams struct {
	GroupID pgtype.UUID `json:"group_id"`
	Status  string      `json:"status"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

func (q *Queries) ListDeliveryLogsByGroupAndStatus(ctx context.Context, arg ListDeliveryLogsByGroupAndStatusParams) ([]DeliveryLog, error) {
	rows, err := q.db.Query(ctx, listDeliveryLogsByGroupAndStatus,
		arg.GroupID,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DeliveryLog
	for rows.Next() {
		var i DeliveryLog
		if err := rows.Scan(
			&i.ID,
			&i.MessageID,
			&i.ProviderID,
			&i.Status,
			&i.ResponseCode,
			&i.ResponseBody,
			&i.DeliveredAt,
			&i.Provider,
			&i.ProviderMessageID,
			&i.RetryCount,
			&i.LastError,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DurationMs,
			&i.AttemptNumber,
			&i.UserID,
			&i.GroupID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDeliveryLogsByMessageID = `-- name: ListDeliveryLogsByMessageID :many
SELECT id, message_id, provider_id, status, response_code, response_body, delivered_at, provider, provider_message_id, retry_count, last_error, metadata, created_at, updated_at, duration_ms, attempt_number, user_id, group_id FROM delivery_logs WHERE message_id = $1 ORDER BY delivered_at DESC
`

func (q *Queries) ListDeliveryLogsByMessageID(ctx context.Context, messageID uuid.UUID) ([]DeliveryLog, error) {
	rows, err := q.db.Query(ctx, listDeliveryLogsByMessageID, messageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DeliveryLog
	for rows.Next() {
		var i DeliveryLog
		if err := rows.Scan(
			&i.ID,
			&i.MessageID,
			&i.ProviderID,
			&i.Status,
			&i.ResponseCode,
			&i.ResponseBody,
			&i.DeliveredAt,
			&i.Provider,
			&i.ProviderMessageID,
			&i.RetryCount,
			&i.LastError,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DurationMs,
			&i.AttemptNumber,
			&i.UserID,
			&i.GroupID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDeliveryLogStatus = `-- name: UpdateDeliveryLogStatus :exec
UPDATE delivery_logs
SET status = $2,
    provider = $3,
    provider_message_id = $4,
    retry_count = $5,
    last_error = $6,
    metadata = $7,
    updated_at = NOW()
WHERE message_id = $1
`

type UpdateDeliveryLogStatusParams struct {
	MessageID         uuid.UUID      `json:"message_id"`
	Status            string         `json:"status"`
	Provider          sql.NullString `json:"provider"`
	ProviderMessageID sql.NullString `json:"provider_message_id"`
	RetryCount        int32          `json:"retry_count"`
	LastError         pgtype.Text    `json:"last_error"`
	Metadata          []byte         `json:"metadata"`
}

func (q *Queries) UpdateDeliveryLogStatus(ctx context.Context, arg UpdateDeliveryLogStatusParams) error {
	_, err := q.db.Exec(ctx, updateDeliveryLogStatus,
		arg.MessageID,
		arg.Status,
		arg.Provider,
		arg.ProviderMessageID,
		arg.RetryCount,
		arg.LastError,
		arg.Metadata,
	)
	return err
}
