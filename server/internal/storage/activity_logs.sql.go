// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: activity_logs.sql

package storage

import (
	"context"
	"net/netip"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createActivityLog = `-- name: CreateActivityLog :one
INSERT INTO activity_logs (group_id, actor_id, action, resource_type, resource_id, changes, comment, ip_address)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, group_id, actor_id, action, resource_type, resource_id, changes, comment, ip_address, created_at
`

type CreateActivityLogParams struct {
	GroupID      uuid.UUID   `json:"group_id"`
	ActorID      pgtype.UUID `json:"actor_id"`
	Action       string      `json:"action"`
	ResourceType string      `json:"resource_type"`
	ResourceID   pgtype.UUID `json:"resource_id"`
	Changes      []byte      `json:"changes"`
	Comment      pgtype.Text `json:"comment"`
	IpAddress    *netip.Addr `json:"ip_address"`
}

func (q *Queries) CreateActivityLog(ctx context.Context, arg CreateActivityLogParams) (ActivityLog, error) {
	row := q.db.QueryRow(ctx, createActivityLog,
		arg.GroupID,
		arg.ActorID,
		arg.Action,
		arg.ResourceType,
		arg.ResourceID,
		arg.Changes,
		arg.Comment,
		arg.IpAddress,
	)
	var i ActivityLog
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.ActorID,
		&i.Action,
		&i.ResourceType,
		&i.ResourceID,
		&i.Changes,
		&i.Comment,
		&i.IpAddress,
		&i.CreatedAt,
	)
	return i, err
}

const getActivityLogByID = `-- name: GetActivityLogByID :one
SELECT id, group_id, actor_id, action, resource_type, resource_id, changes, comment, ip_address, created_at FROM activity_logs WHERE id = $1
`

func (q *Queries) GetActivityLogByID(ctx context.Context, id uuid.UUID) (ActivityLog, error) {
	row := q.db.QueryRow(ctx, getActivityLogByID, id)
	var i ActivityLog
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.ActorID,
		&i.Action,
		&i.ResourceType,
		&i.ResourceID,
		&i.Changes,
		&i.Comment,
		&i.IpAddress,
		&i.CreatedAt,
	)
	return i, err
}

const listActivityLogsByActorID = `-- name: ListActivityLogsByActorID :many
SELECT id, group_id, actor_id, action, resource_type, resource_id, changes, comment, ip_address, created_at FROM activity_logs
WHERE actor_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListActivityLogsByActorIDParams struct {
	ActorID pgtype.UUID `json:"actor_id"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

func (q *Queries) ListActivityLogsByActorID(ctx context.Context, arg ListActivityLogsByActorIDParams) ([]ActivityLog, error) {
	rows, err := q.db.Query(ctx, listActivityLogsByActorID, arg.ActorID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ActivityLog
	for rows.Next() {
		var i ActivityLog
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.ActorID,
			&i.Action,
			&i.ResourceType,
			&i.ResourceID,
			&i.Changes,
			&i.Comment,
			&i.IpAddress,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActivityLogsByGroupID = `-- name: ListActivityLogsByGroupID :many
SELECT id, group_id, actor_id, action, resource_type, resource_id, changes, comment, ip_address, created_at FROM activity_logs
WHERE group_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListActivityLogsByGroupIDParams struct {
	GroupID uuid.UUID `json:"group_id"`
	Limit   int32     `json:"limit"`
	Offset  int32     `json:"offset"`
}

func (q *Queries) ListActivityLogsByGroupID(ctx context.Context, arg ListActivityLogsByGroupIDParams) ([]ActivityLog, error) {
	rows, err := q.db.Query(ctx, listActivityLogsByGroupID, arg.GroupID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ActivityLog
	for rows.Next() {
		var i ActivityLog
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.ActorID,
			&i.Action,
			&i.ResourceType,
			&i.ResourceID,
			&i.Changes,
			&i.Comment,
			&i.IpAddress,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActivityLogsByResource = `-- name: ListActivityLogsByResource :many
SELECT id, group_id, actor_id, action, resource_type, resource_id, changes, comment, ip_address, created_at FROM activity_logs
WHERE resource_type = $1 AND resource_id = $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListActivityLogsByResourceParams struct {
	ResourceType string      `json:"resource_type"`
	ResourceID   pgtype.UUID `json:"resource_id"`
	Limit        int32       `json:"limit"`
	Offset       int32       `json:"offset"`
}

func (q *Queries) ListActivityLogsByResource(ctx context.Context, arg ListActivityLogsByResourceParams) ([]ActivityLog, error) {
	rows, err := q.db.Query(ctx, listActivityLogsByResource,
		arg.ResourceType,
		arg.ResourceID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ActivityLog
	for rows.Next() {
		var i ActivityLog
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.ActorID,
			&i.Action,
			&i.ResourceType,
			&i.ResourceID,
			&i.Changes,
			&i.Comment,
			&i.IpAddress,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
